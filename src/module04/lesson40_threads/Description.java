package module04.lesson40_threads;

/**
 * Introduction to multithreaded programming. Create and run threads. Volatile, synchronized, wait, notify.
 *
 * 1. Определение  Thread.
 * Принято называть нитями (дословный перевод) или программными потоками.
 * В противовес stream’ам, которые называют потоками ввода-вывода.
 *
 * Многопоточность - это принцип построения программы, при котором несколько блоков кода могут выполняться одновременно.
 *
 * Цели многопоточности:
 * - увеличение производительности;
 * - параллельное выполнение функций.
 *
 *
 * 2. Жизненный цикл Thread.
 * - new - при создании нити;
 * - runnable - после вызова метода start():
 *      - ready - в режиме готовности к run():
 *              - time waiting - в режиме ожидания на определенное время;
 *              - waiting - в режиме ожидания;
 *              - blocked - при входе в блок synchronized;
 *      - running - выполнение run();
 * - terminated - после завершения работы.
 *
 * см. original.jpeg
 *
 * public enum State {
 *  NEW,
 *  RUNNABLE,
 *  BLOCKED,
 *  WAITING,
 *  TIMED_WAITING,
 *  TERMINATED;
 * }
 * class ThreadStates
 *
 * 2.1. Приоритеты потоков
 * Каждый поток Java имеет приоритет, который помогает операционной системе определять порядок,
 * в котором планируются потоки.
 *
 * Приоритеты потоков Java находятся в диапазоне от MIN_PRIORITY (константа 1) до MAX_PRIORITY (константа 10).
 * По умолчанию каждому потоку устанавливается приоритет NORM_PRIORITY (константа 5).
 *
 * Потоки с более высоким приоритетом более важны для программы, и в первую очередь им должно выделяться процессорное
 * время. Однако приоритеты потоков не могут гарантировать порядок, в котором выполняются потоки,
 * и очень сильно зависят от платформы.
 *
 *
 * 3. Способы создания нитей.
 * Когда мы создаем объект типа Thread, нить при этом еще не создается.
 * Thread – это не нить, нить создаст сама Java-машина, когда будет вызван метод start().
 * А Thread — это специальный объект Java-машины, который позволяет получать информацию о нити и немного управлять ей.
 *
 * - Наследование от Thread. - class ThreadCreation
 *
 * - Реализация Runnable. - class ThreadRunnable
 *
 * 3.1. Обработка исключений, вызванных в другом трэде.
 * Интерфейс UncaughtExceptionHandler.
 *
 * class CaughtExceptions
 *
 *
 * 4. Ключевые слова и методы thread "volatile", "synchronized", "sleep", "wait", "notify", "join", "yield" и их особенности.
 *
 * - sleep(timeout) - останавливает текущую нить на timeout миллисекунд;
 * - yield() - текущая нить пропускает свой ход, JVM приступает к выполнению следующей нити.
 *
 * class ThreadMethods
 *
 * * - join() и join(timeout) - текущая нить присоединяется к нити, у объекта которой был вызван этот метод
 *
 * class ThreadJoin
 *
 * - wait() и wait(timeout) - метод можно вызвать только внутри блока synchronized у объекта-мьютекса,
 * который был заблокирован текущей нитью, в противном случае метод выкинет исключение IllegalMonitorStateException;
 * в результате вызова метода снимается блокировка с объекта-мьютекссса и он становится доступен для захвата и блокировки другой нитью.
 *
 * - notify()  - пробуждает одну нить из заблокированных по одному объекту-мьютексу;
 * - notifyAll() - пробуждает все нити, заблокированные по одному объекту-мьютексу, но как только одна из них завладеет
 * монитором, остальные снова блокируются
 *
 * package wait_notify
 *
 * - interrupt() - прерывает работу текущей нити
 *
 * class ExampleInterruption
 *
 * "volatile" - ключевое слово для переменных (не final):
 * - помечается такая переменная, к которой обращаются из разных нитей, чтобы JVM не помещала ее в кэш;
 * - безопасное чтение/запись, но не изменение (count++ - 3 операции, могут быть прерваны).
 *
 * class VolatileExample
 *
 * "synchronized" - ключевое слово для методов или блоков, которым помечаются те части кода, доступ к которым должен быть
 * заблокирован, если одна нить уже им пользуется.
 *
 * "thread-safe" - потокобезопасный:
 * - все immutable объекты;
 * - все классы-обертки;
 * - StringBuffer;
 * - все atomic объекты.
 *
 * 5. Понятие "мьютекс", "монитор" и "семафор".
 *
 * "mutex" (mutual exclusion - взаимное исключение):
 *  - это специальный невидимый объект для синхронизации нитей;
 *  - прикреплен к каждому объекту;
 *  - прямой доступ к мьютексу только у JVM;
 *  - имеет 2 состояния - свободен/занят;
 *  - работать с мьютексом можно посредством монитора;
 *  - является одноместным семафором.
 *
 *  "monitor" - это специальный механизм - надстройка над мьютексом, которая позволяет обеспечить правильную работу с ним.
 *  Монитор реализован с помощью ключевого слова "synchronized" (невидимая часть кода).
 *
 *  "semaphore" - средство синхронизации доступа к какому-то ресурсу со счетчиком, который указывает, сколько нитей
 *  имеют одновременный доступ к ресурсу.
 *  Семафоры представлены классом Semaphore.
 *  Semaphore(int permits);
 *  Semaphore(int permits, boolean fair);
 *  - где permits - начальное и максимальное значение счечика;
 *  - fair - установление порядка, в котором нити будут получать доступ:
 *  true - в том порядке, в котором они запрашивали, false - определяется планировщиком потоков.
 *
 *  Коротко:
 *  - мьютекс - флаг блокировки объекта (только для одного потока);
 *  - монитор - скрытая логика мьютекса, которая исполняется JVM на месте synchronized кода;
 *  - семафор - флаг блокировки объектов (количество можно настроить).
 *
 *
 * 6. Взаимная блокировка - DeadLock.
 * Взаимная блокировка описывает ситуацию, когда два или более потока блокируются, ожидая друг друга.
 * Взаимная блокировка возникает, когда нескольким потокам нужны одинаковые блокировки, но они получают их
 * в разном порядке. Многопоточная программа Java может пострадать от состояния взаимоблокировки, поскольку
 * ключевое слово synchronized заставляет выполняющийся поток блокироваться в ожидании блокировки или монитора,
 * связанного с указанным объектом.
 * http://proglang.su/java/thread-deadlock
 *
 * Лучшая стратегия - это продуманная архитектура и набор правил, когда можно использоват блокировки (захват мьютексов)
 * и в каком порядке.
 *
 * 7. Гонка данных - Data race
 * Это проблема, которая может возникнуть, когда два и более потоков обращаются к одной и той же переменной
 * и как минимум один поток ее изменяет.
 *
 * Выход - сонхронизация доступа к такой переменной.
 *
 * class DeadLockSample
 * class DecisionOfDeadLock
 *
 * @author Kamila Meshcheryakova
 * created by 20.11.2020
 */
public class Description {
}
