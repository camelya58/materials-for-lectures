package module03.lesson25.description;

/**
 * List interface.
 * 1. Почему существует такое многообразие коллекций? потому что для каждой ситуации требуются те или иные преимущества
 * той или иной коллекции.
 * Базовый интерфейс для коллекций, которые содержат упорядоченные элементы, иными словами список элементов.
 * List - упорядоченная последовательность элементов, позволяющая хранить дубликаты и null. Каждый элемент имеет индекс.
 *
 * 2. Имеет несколько реализаций:
 * ArrayList, LinkedList, Vector (синхронизированный ArrayList) и его наследник Stack(LIFO).
 *
 * 3. ArrayList - динамический массив, который автоматически изменяет свой размер.
 * DEFAULT_CAPACITY = 10.
 * Поэтому если мы хотим добавить 11 элемент, то будет создан новый список на большее количество элементов,
 * скопирует все элементы из старого листа в новый и старый пометит на удаление.
 * Поэтому, можно увеличить производительность и сразу установить нужный размер или примерный размер.
 *
 * В основе лежит массив типа Object.
 *
 * 4. Конструкторы ArrayList.
 *
 * 5. Методы ArrayList.
 * - add(element)/(index,element) - добавляет элемент в конец списка или на заданную позицию, элементы хранятся в порядке добавления.
 * - toString() - переопределен заранее.
 * - size() - возвращает количество заполненных элементов в списке.
 * - get(index) - позволяет получить элемент по индексу.
 * - set(index, element) - позволяет изменить элемент по индексу.
 * - addAll(Collection)/(index, Collection) - позволяет добавить сразу всю коллекцию в конец или на заданную позицию.
 * - indexOf(element) - позволяет получить индекс по элементу - выдает первое совпадение.
 * - lastIndexOf(element) - позволяет получить индекс по элементу - выдает последнее совпадение.
 * - clear() - позволяет очистить весь список.
 * - isEmpty() - позволяет узнать, содержатся ли в списке элементы.
 * - contains(element), (Collection) - позволяет узнать, содержится ли в списке конкретный элемент или коллекция.
 * - remove(element)/(index) - позволяет удалить элемент (первое совпадение) по значению или индексу, нельзя использовать в итерации.
 *
 * 6. Методы ArrayList и связанные.
 * - Arrays.asList(T[] array) - позволяет создать из массива лист.
 * - removeAll(Collection) - удаляет все элементы, совпадающие с элементами коллекции.
 * - retainAll(Collection) - удаляет все элементы, не совпадающие с элементами коллекции.
 * - subList(fromIndex, toIndex) - позволяет создать саблист из листа с(вкл) и по(не вкл) определенный индекс элемента.
 * - toArray() - позволяет представить лист как массив Object[].
 * - toArray(T[] array) - создает массив типа array, но заполняет элементами того массива, который вызывает метод, а не array
 * - List.of(E... elements) - позволяет создать лист из перечесления элементов.
 * - List.copyOf(Collection) - копирует все элементы из коллекции.
 *
 * 7. Iterator
 *  "Повторитель", используется для того,  чтобы перебрать все элементы коллекции (tlbyj;ls.
 *  Отличается от forEach тем, что мы можем удалить элемент при переборе элементов.
 *
 * 8. LinkedList
 * Очень отличается по строению от ArrayList.
 * Это уже не массив, а связный список, где каждый элемент знает (хранит ссылку) о своих соседях - предыдущем и последующем.
 * Но поскольку и тот и другой имплементируют List набор методов во многом похож, но у каждого есть и свои особенные методы.
 * Первый элемент не ссылается на предыдущий, у него ссылка на null, то же самое у последнего с последующим элементом - null.
 *
 * 8.1. Методы LinkedList.
 * add() - работает также. Элементы хранятся в порядке добавления.
 * add(index, element) - добавляется легко и быстро, предыдущий и последующий элементы просто меняют ссылки на новый элемент.
 * также легко и быстро работает методы remove(element)/(index)
 * а вот метод get(index) - работает иначе. У LinkedList нет внутри нумерации индексов(это лишь номер позиции),
 * каждый раз начинается перебор с головы листа, пока по ссылкам не дойдет до нужного элемента или с хвоста, ели так ближе.
 * по такому же принципу метод indexOf(Object);
 *
 * 8.2. Когда следует использовать:
 * - невелико количество операций по получению элементо по индексу;
 * - велико количество операций по добавлению и удалению элементов.
 *
 * 9. ListIterator
 * Расширяет возможности обычного Iterator, позволяет работать не только с следующим элементом, но и с предыдущим.
 * Выполним проверку слова на то является ли он палиндромом (одинаково читается, как с одной, так и с другой стороны).
 *
 * 10. Вопросы к собеседованию.
 * - что такое ArrayList?
 * - что такое LinkedList?
 * - при каких случаях нужно использовать ArrayList? а когда LinkedList для повышения производительности?
 * - как правильно удалять все элементы в списке?
 * - в чем отличие ListIterator от Iterator?
 *
 * @author Kamila Meshcheryakova
 * created 25.09.2020
 */
public class Description {
    public static void main(String[] args) {
    }
}
